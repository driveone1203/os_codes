// Peterson's sol
#include <stdio.h>
#include <pthread.h>
int flag[2];
int turn;
const int MAX = 1e9;
int ans = 0;
void lock_init()
{
    // Initialize lock by resetting the desire of
    // both the threads to acquire the locks.
    // And, giving turn to one of them.
    flag[0] = flag[1] = 0;
    turn = 0;
}
// Executed before entering critical section
void lock(int self)
{
    // Set flag[self] = 1 saying you want to acquire lock
    flag[self] = 1;

    // But, first give the other thread the chance to
    // acquire lock
    turn = 1-self;

    // Wait until the other thread looses the desire
    // to acquire lock or it is your turn to get the lock.
    while (flag[1-self]==1 && turn==1-self) ;
}
// Executed after leaving critical section
void unlock(int self)
{
    // You do not desire to acquire lock in future.
    // This will allow the other thread to acquire
    // the lock.
    flag[self] = 0;
}
// A Sample function run by two threads created 
// in main()
void* func(void *s)
{
    int i = 0;
    int self = (int *)s;
    printf("Thread Entered: %d\n", self);

    lock(self);

    // Critical section (Only one thread
    // can enter here at a time)
    for (i=0; i<MAX; i++)
        ans++;

    unlock(self);
}
// Driver code
int main()
{
    // Initialized the lock then fork 2 threads
    pthread_t p1, p2;
    lock_init();
    // Create two threads (both run func) 
    pthread_create(&p1, NULL, func, (void*)0);
    pthread_create(&p2, NULL, func, (void*)1);
    // Wait for the threads to end.
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf("Actual Count: %d | Expected Count: %d\n", ans, MAX*2);
    return 0;
}


// Sync hardware
#include <pthread.h>
#include <stdio.h>
#define N 5
// Mutex variable
pthread_mutex_t lock;
// Shared variable
int count = 0;
void *runner(void *param);
int main(int argc, char *argv[])
{
    pthread_t threads[N];
    int i;
    pthread_mutex_init(&lock, NULL);
    for (i = 0; i < N; i++)
    {
        pthread_create(&threads[i], NULL, runner, (void *)i);
    }
    for (i = 0; i < N; i++)
    {
        pthread_join(threads[i], NULL);
    }
    // Destroy the mutex variable
    pthread_mutex_destroy(&lock);
    return 0;
}
void *runner(void *param)
{
    int i, j;
    long myid = (long)param;
    for (i = 0; i < 1000; i++)
    {
        // Lock the mutex variable before accessing the shared variable
        pthread_mutex_lock(&lock);
        // Access the shared variable
        count++;
        // Unlock the mutex variable after accessing the shared variable
        pthread_mutex_unlock(&lock);
    }
    printf("Thread %ld has counted to %d\n", myid, count);
}


// Bakery algo
#include "pthread.h"
#include "stdio.h"
#include "unistd.h"
#include "string.h"
#define MEMBAR __sync_synchronize()
#define THREAD_COUNT 8
volatile int tickets[THREAD_COUNT];
volatile int choosing[THREAD_COUNT];
// VOLATILE used to prevent the compiler
// from applying any optimizations.
volatile int resource;
void lock(int thread)
{
    // Before getting the ticket number
    //"choosing" variable is set to be true
    choosing[thread] = 1;
    MEMBAR;
    // Memory barrier applied
    int max_ticket = 0;
    // Finding Maximum ticket value among current threads
    for (int i = 0; i < THREAD_COUNT; ++i) {
        int ticket = tickets[i];
        max_ticket = ticket > max_ticket ? ticket : max_ticket;
    }
    // Allotting a new ticket value as MAXIMUM + 1
    tickets[thread] = max_ticket + 1;
    MEMBAR;
    choosing[thread] = 0;
    MEMBAR;
    // The ENTRY Section starts from here
    for (int other = 0; other < THREAD_COUNT; ++other) {
        // Applying the bakery algorithm conditions
        while (choosing[other]) {
        }
        MEMBAR;
        while (tickets[other] != 0 && (tickets[other]
                                        < tickets[thread]
                                    || (tickets[other]
                                            == tickets[thread]
                                        && other < thread))) {
        }
    }
}
// EXIT Section
void unlock(int thread)
{
    MEMBAR;
    tickets[thread] = 0;
}
// The CRITICAL Section
void use_resource(int thread)
{
    if (resource != 0) {
        printf("Resource was acquired by %d, but is still in-use by %d!\n",
            thread, resource);
    }
    resource = thread;
    printf("%d using resource...\n", thread);
    MEMBAR;
    sleep(2);
    resource = 0;
}
// A simplified function to show the implementation
void* thread_body(void* arg)
{
    long thread = (long)arg;
    lock(thread);
    use_resource(thread);
    unlock(thread);
    return NULL;
}
int main(int argc, char** argv)
{
    memset((void*)tickets, 0, sizeof(tickets));
    memset((void*)choosing, 0, sizeof(choosing));
    resource = 0;
    // Declaring the thread variables
    pthread_t threads[THREAD_COUNT];
    for (int i = 0; i < THREAD_COUNT; ++i) {
        // Creating a new thread with the function
        //"thread_body" as its thread routine
        pthread_create(&threads[i], NULL, &thread_body, (void*)((long)i));
    }
    for (int i = 0; i < THREAD_COUNT; ++i) {
        // Reaping the resources used by
        // all threads once their task is completed !
        pthread_join(threads[i], NULL);
    }
    return 0;
}
