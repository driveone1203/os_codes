// FCFS
#include <stdio.h>
void bubbleSort(int n, int *p, int *at, int *bt) {
	int i, j, temp;
	for (i=0; i<n-1; i++) {
		for (j=0; j<n-i-1; j++) {
			if (at[j] > at[j+1]) {
				temp = at[j];
				at[j] = at[j+1];
				at[j+1] = temp;
				temp = p[j];
				p[j] = p[j+1];
				p[j+1] = temp;
				temp = bt[j];
				bt[j] = bt[j+1];
				bt[j+1] = temp;
			}
		}
	}
}
void calcCt(int n, int *at, int *bt, int *ct) {
	int i, temp;
	ct[0] = at[0] + bt[0];
	for (i=1; i<n; i++) {
		temp = 0;
		if (ct[i-1] < at[i]) {
			temp = at[i] - ct[i-1];
		}
		ct[i] = ct[i-1] + bt[i] + temp;
	}
}
void calcTatWt(int n, int *ct, int *at, int *bt, int *tat, int *wt) {
	int i;
	for (i=0; i<n; i++) {
		tat[i] = ct[i] - at[i];
		wt[i] = tat[i] - bt[i];
	}
}
float average(int n, int *arr) {
	int i, sum=0;
	for (i=0; i<n; i++) {
		sum += arr[i];
	}
	return ((sum+0.0) / n);
}
void main() {
	int i;
	int n = 3;
	int p[3] = {1, 2, 3};
	int at[3] = {0, 5, 3};
	int bt[3] = {2, 6, 4};
	int ct[3], tat[3], wt[3];
	float atat, awt;
	printf("FCFS Scheduling Algorithm\n");	
	bubbleSort(n, p, at, bt);
	calcCt(n, at, bt, ct);
	calcTatWt(n, ct, at, bt, tat, wt);
	atat = average(n, tat);
	awt = average(n, wt);
	printf("Process, AT, BT, CT, TAT, WT\n");
	for (i=0; i<n; i++) {
		printf("%d: %d, %d, %d, %d, %d\n", p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
	}
	printf("ATAT: %f; AWT: %f\n", atat, awt);
}


// SJF NP
#include <stdio.h>
struct Process {
    int pid;        // Process ID
    int arrival;    // Arrival Time
    int burst;      // Burst Time
    int waiting;    // Waiting Time
    int turnaround; // Turnaround Time
    int completed;  // Flag to check if process is completed or not
};
// Function to find the process with shortest burst time among the arrived processes
int findShortestJob(struct Process processes[], int n, int currentTime) {
    int shortestIndex = -1;
    int shortestBurst = 999999; // Initializing with a large value
    for (int i = 0; i < n; i++) {
        if (processes[i].arrival <= currentTime && !processes[i].completed) {
            if (processes[i].burst < shortestBurst) {
                shortestBurst = processes[i].burst;
                shortestIndex = i;
            }
        }
    }
    return shortestIndex;
}
// Function to calculate waiting and turnaround times for all processes
void calculateTimes(struct Process processes[], int n) {
    int currentTime = 0;
    float totalWaitingTime = 0, totalTurnaroundTime = 0;
    for (int i = 0; i < n; i++) {
        int shortestIndex = findShortestJob(processes, n, currentTime);
        if (shortestIndex == -1) {
            printf("Error: No process found at time %d\n", currentTime);
            return;
        }
        // Update current time
        currentTime = currentTime + processes[shortestIndex].burst;
        // Update waiting and turnaround times for the selected process
        processes[shortestIndex].waiting = currentTime - processes[shortestIndex].arrival - processes[shortestIndex].burst;
        processes[shortestIndex].turnaround = currentTime - processes[shortestIndex].arrival;

        // Update total waiting and turnaround times
        totalWaitingTime += processes[shortestIndex].waiting;
        totalTurnaroundTime += processes[shortestIndex].turnaround;
        // Mark the process as completed
        processes[shortestIndex].completed = 1;
        printf("Process %d: Waiting Time=%d, Turnaround Time=%d\n", processes[shortestIndex].pid,
               processes[shortestIndex].waiting, processes[shortestIndex].turnaround);
    }
    // Print average waiting and turnaround times
    printf("Average Waiting Time = %f\n", totalWaitingTime / n);
    printf("Average Turnaround Time = %f\n", totalTurnaroundTime / n);
}
int main() {
    // Predefined arrival and burst times
    int arrival[] = {0, 1, 2, 3}; // Arrival times
    int burst[] = {6, 8, 7, 3};   // Burst times
    int n = sizeof(arrival) / sizeof(arrival[0]);
    printf("SJF Non-preemptive\n");
    struct Process processes[n];
    // Initialize processes
    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        processes[i].arrival = arrival[i];
        processes[i].burst = burst[i];
        processes[i].waiting = 0;
        processes[i].turnaround = 0;
        processes[i].completed = 0;
    }
    // Perform SJF scheduling
    calculateTimes(processes, n);

    return 0;
}
